[{"content":"Ts快速入门 编程语言介绍 ArkTS是HarmonyOS优选的主力应用开发语言。它在TypeScript（简称TS）的基础上，匹配ArkUI框架，扩展了声明式UI、状态管理等相应的能力，让开发者以更简洁、更自然的方式开发跨端应用。要了解什么是ArkTS，我们首先要了解下ArkTS、TypeScript和JavaScript之间的关系：\nJavaScript是一种属于网络的高级脚本语言，已经被广泛用于Web应用开发，常用来为网页添加各式各样的动态功能，为用户提供更流畅美观的浏览效果。 TypeScript 是 JavaScript 的一个超集，它扩展了 JavaScript 的语法，通过在JavaScript的基础上添加静态类型定义构建而成，是一个开源的编程语言。 ArkTS兼容TypeScript语言，拓展了声明式UI、状态管理、并发任务等能力。 由此可知，TypeScript是JavaScript的超集，ArkTS则是TypeScript的超集，他们的关系如下图所示：\n在学习ArkTS声明式的相关语法之前，我们首先学习下TypeScript的基础语法。\r基础类型 TypeScript支持一些基础的数据类型，如布尔型、数组、字符串等，下文举例几个较为常用的数据类型，我们来了解下他们的基本使用。\n布尔值\nTypeScript中可以使用boolean来表示这个变量是布尔值，可以赋值为true或者false。\nlet isDone: boolean = false; 数字\nTypeScript里的所有数字都是浮点数，这些浮点数的类型是 number。除了支持十进制，还支持二进制、八进制、十六进制。\nlet decLiteral: number = 2023; let binaryLiteral: number = 0b11111100111; let octalLiteral: number = 0o3747; let hexLiteral: number = 0x7e7; 字符串\nTypeScript里使用 string表示文本数据类型， 可以使用双引号（ \u0026ldquo;）或单引号（\u0026rsquo;）表示字符串。\nlet name: string = \u0026#34;Jacky\u0026#34;;name = \u0026#34;Tom\u0026#34;;name = \u0026#39;Mick\u0026#39;; 数组\nTypeScrip有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组。\nlet list: number[] = [1, 2, 3]; 第二种方式是使用数组泛型，Array\u0026lt;元素类型\u0026gt;。\nlet list: Array\u0026lt;number\u0026gt; = [1, 2, 3]; 元组\n元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。\nlet x: [string, number]; x = [\u0026#39;hello\u0026#39;, 10];// OK x = [10, \u0026#39;hello\u0026#39;]; // Error 枚举\nenum类型是对JavaScript标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字。\nenum Color {Red, Green, Blue}; let c: Color = Color.Green; Unknown\n有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。那么我们可以使用unknown类型来标记这些变量。\nlet notSure: unknown = 4; notSure = \u0026#39;maybe a string instead\u0026#39;; notSure = false; Void\n当一个函数没有返回值时，你通常会见到其返回值类型是 void。\nfunction test(): void { console.log(\u0026#39;This is function is void\u0026#39;);} Null 和 Undefined\nTypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。\nlet u: undefined = undefined;let n: null = null; 联合类型\n联合类型（Union Types）表示取值可以为多种类型中的一种。\nlet myFavoriteNumber: string | number;myFavoriteNumber = \u0026#39;seven\u0026#39;;myFavoriteNumber = 7; 条件语句 条件语句用于基于不同的条件来执行不同的动作。TypeScript 条件语句是通过一条或多条语句的执行结果（True 或 False）来决定执行的代码块。\nif 语句\nTypeScript if 语句由一个布尔表达式后跟一个或多个语句组成。\nvar num:number = 5if (num \u0026gt; 0) { console.log(\u0026#39;数字是正数\u0026#39;) } if\u0026hellip;else 语句\n一个 if 语句后可跟一个可选的 else 语句，else 语句在布尔表达式为 false 时执行。\nvar num:number = 12; if (num % 2==0) { console.log(\u0026#39;偶数\u0026#39;); } else { console.log(\u0026#39;奇数\u0026#39;); } if\u0026hellip;else if\u0026hellip;.else 语句\nif\u0026hellip;else if\u0026hellip;.else 语句在执行多个判断条件的时候很有用。\nvar num:number = 2 if(num \u0026gt; 0) { console.log(num+\u0026#39; 是正数\u0026#39;) } else if(num \u0026lt; 0) { console.log(num+\u0026#39; 是负数\u0026#39;) } else { console.log(num+\u0026#39; 为0\u0026#39;) } switch…case 语句\n一个 switch 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 switch case 进行检查。\nvar grade:string = \u0026#39;A\u0026#39;; switch(grade) { case \u0026#39;A\u0026#39;: { console.log(\u0026#39;优\u0026#39;); break; } case \u0026#39;B\u0026#39;: { console.log(\u0026#39;良\u0026#39;); break; } case \u0026#39;C\u0026#39;: { console.log(\u0026#39;及格\u0026#39;); break; } case \u0026#39;D\u0026#39;: { console.log(\u0026#39;不及格\u0026#39;); break; } default: { console.log(\u0026#39;非法输入\u0026#39;); break; } } 函数 函数是一组一起执行一个任务的语句，函数声明要告诉编译器函数的名称、返回类型和参数。TypeScript可以创建有名字的函数和匿名函数，其创建方法如下：\n// 有名函数function add(x, y) { return x + y;} // 匿名函数let myAdd = function (x, y) { return x + y;}; 为函数定义类型\n为了确保输入输出的准确性，我们可以为上面那个函数添加类型：\n// 有名函数：给变量设置为number类型function add(x: number, y: number): number { return x + y;} // 匿名函数：给变量设置为number类型let myAdd = function (x: number, y: number): number { return x + y;}; 可选参数\n在TypeScript里我们可以在参数名旁使用 ?实现可选参数的功能。 比如，我们想让lastName是可选的：\nfunction buildName(firstName: string, lastName?: string) { if (lastName) return firstName + \u0026#39; \u0026#39; + lastName; else return firstName;} let result1 = buildName(\u0026#39;Bob\u0026#39;);let result2 = buildName(\u0026#39;Bob\u0026#39;, \u0026#39;Adams\u0026#39;); 剩余参数\n剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 可以使用省略号（ \u0026hellip;）进行定义：\nfunction getEmployeeName(firstName: string, ...restOfName: string[]) { return firstName + \u0026#39; \u0026#39; + restOfName.join(\u0026#39; \u0026#39;);} let employeeName = getEmployeeName(\u0026#39;Joseph\u0026#39;, \u0026#39;Samuel\u0026#39;, \u0026#39;Lucas\u0026#39;, \u0026#39;MacKinzie\u0026#39;); 箭头函数\nES6版本的TypeScript提供了一个箭头函数，它是定义匿名函数的简写语法，用于函数表达式，它省略了function关键字。箭头函数的定义如下，其函数是一个语句块：\n( [param1, parma2,…param n] )=\u0026gt; { // 代码块} 其中，括号内是函数的入参，可以有0到多个参数，箭头后是函数的代码块。我们可以将这个箭头函数赋值给一个变量，如下所示：\nlet arrowFun = ( [param1, parma2,…param n] )=\u0026gt; { // 代码块} 如何要主动调用这个箭头函数，可以按如下方法去调用：\narrowFun(param1, parma2,…param n) 后面，我们在学习HarmonyOS应用开发时会经常用到箭头函数。例如，给一个按钮添加点击事件，其中onClick事件中的函数就是箭头函数。\nButton(\u0026#34;Click Now\u0026#34;) .onClick(() =\u0026gt; { console.info(\u0026#34;Button is click\u0026#34;) }) 类 TypeScript支持基于类的面向对象的编程方式，定义类的关键字为 class，后面紧跟类名。类描述了所创建的对象共同的属性和方法。\n类的定义\n例如，我们可以声明一个Person类，这个类有3个成员：一个是属性（包含name和age)，一个是构造函数，一个是getPersonInfo方法，其定义如下所示。\nclass Person { private name: string private age: number constructor(name: string, age: number) { this.name = name; this.age = age; } public getPersonInfo(): string { return `My name is ${this.name} and age is ${this.age}`; } } 通过上面的Person类，我们可以定义一个人物Jacky并获取他的基本信息，其定义如下：\nlet person1 = new Person(\u0026#39;Jacky\u0026#39;, 18); person1.getPersonInfo(); 继承\n继承就是子类继承父类的特征和行为，使得子类具有父类相同的行为。TypeScript中允许使用继承来扩展现有的类，对应的关键字为extends。\nsuper关键字可以用来访问父类的构造方法\nclass Employee extends Person { private department: string constructor(name: string, age: number, department: string) { super(name, age); this.department = department; } public getEmployeeInfo(): string { return this.getPersonInfo() + ` and work in ${this.department}`; } } 通过上面的Employee类，我们可以定义一个人物Tom，这里可以获取他的基本信息，也可以获取他的雇主信息，其定义如下：\nlet person2 = new Employee(\u0026#39;Tom\u0026#39;, 28, \u0026#39;HuaWei\u0026#39;);person2.getPersonInfo();person2.getEmployeeInfo(); 在TypeScript中，有public、private、protected修饰符，其功能和具体使用场景大家可以参考TypeScript的相关学习资料，进行拓展学习。\n模块 随着应用越来越大，通常要将代码拆分成多个文件，即所谓的模块（module）。模块可以相互加载，并可以使用特殊的指令 export 和 import 来交换功能，从另一个模块调用一个模块的函数。\n两个模块之间的关系是通过在文件级别上使用 import 和 export 建立的。模块里面的变量、函数和类等在模块外部是不可见的，除非明确地使用 export 导出它们。类似地，我们必须通过 import 导入其他模块导出的变量、函数、类等。\n导出\n任何声明（比如变量，函数，类，类型别名或接口）都能够通过添加export关键字来导出，例如我们要把NewsData这个类导出，代码示意如下：\nexport class NewsData { title: string; content: string; constructor(title: string, content: string) { this.title = title; this.content = content; } } 导入\n模块的导入操作与导出一样简单。 可以使用以下 import形式之一来导入其它模块中的导出内容。\nimport { NewsData } from \u0026#39;../common/bean/NewsData\u0026#39;; 迭代器 当一个对象实现了Symbol.iterator属性时，我们认为它是可迭代的。一些内置的类型如Array，Map，Set，String，Int32Array，Uint32Array等都具有可迭代性。\nfor..of 语句\nfor..of会遍历可迭代的对象，调用对象上的Symbol.iterator方法。 下面是在数组上使用for..of的简单例子：用于遍历对象\nlet someArray = [1, \u0026#34;string\u0026#34;, false]; for (let entry of someArray) { console.log(entry); // 1, \u0026#34;string\u0026#34;, false} for..of vs. for..in 语句\nfor..of和for..in均可迭代一个列表，但是用于迭代的值却不同：for..in迭代的是对象的键，而for..of则迭代的是对象的值。用于遍历下标，打印下标\nlet list = [4, 5, 6]; for (let i in list) { console.log(i); // \u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;,} for (let i of list) { console.log(i); // \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;} ","permalink":"https://hanson-study.netlify.app/posts/tech/ts%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","summary":"Ts快速入门 编程语言介绍 ArkTS是HarmonyOS优选的主力应用开发语言。它在TypeScript（简称TS）的基础上，匹配ArkUI框架，扩展了声明式UI、状态管理等相应的能力，让开发者以更简洁、更自然的方式开发跨端应用。要了解什么是ArkTS，我们首先要了解下ArkTS、","title":"鸿蒙应用开发Ts快速入门"},{"content":"1. 介绍 scan命令的作用和keys *的作用类似，主要用于查找redis中的键，但是在正式的生产环境中一般不会直接使用keys *这个命令，因为他会返回所有的键，如果键的数量很多会导致查询时间很长，进而导致服务器阻塞，所以需要scan来进行更细致的查找\nscan总共有这几种命令：scan、sscan、hscan、zscan，分别用于迭代数据库中的：数据库中所有键、集合键、哈希键、有序集合键，命令具体结构如下：\nscan cursor [MATCH pattern] [COUNT count] [TYPE type] sscan key cursor [MATCH pattern] [COUNT count] hscan key cursor [MATCH pattern] [COUNT count] zscan key cursor [MATCH pattern] [COUNT count] 2. scan scan cursor [MATCH pattern] [COUNT count] [TYPE type]，cursor表示游标，指查询开始的位置，count默认为10，查询完后会返回下一个开始的游标，当返回0的时候表示所有键查询完了\n127.0.0.1:6379[2]\u0026gt; scan 0 1) \u0026#34;3\u0026#34; 2) 1) \u0026#34;mystring\u0026#34; 2) \u0026#34;myzadd\u0026#34; 3) \u0026#34;myhset\u0026#34; 4) \u0026#34;mylist\u0026#34; 5) \u0026#34;myset2\u0026#34; 6) \u0026#34;myset1\u0026#34; 7) \u0026#34;mystring1\u0026#34; 8) \u0026#34;mystring3\u0026#34; 9) \u0026#34;mystring4\u0026#34; 10) \u0026#34;myset\u0026#34; 127.0.0.1:6379[2]\u0026gt; scan 3 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;myzadd1\u0026#34; 2) \u0026#34;mystring2\u0026#34; 3) \u0026#34;mylist2\u0026#34; 4) \u0026#34;myhset1\u0026#34; 5) \u0026#34;mylist1\u0026#34; MATCH可以采用模糊匹配找出自己想要查找的键，这里的逻辑是先查出20个，再匹配，而不是先匹配再查询，这里加上count 20是因为默认查出的10个数中可能不能包含所有的相关项，所以把范围扩大到查20个，我这里测试的键总共有15个\n127.0.0.1:6379[2]\u0026gt; scan 0 match mylist* count 20 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;mylist\u0026#34; 2) \u0026#34;mylist2\u0026#34; 3) \u0026#34;mylist1\u0026#34; TYPE可以根据具体的结构类型来匹配该类型的键\n127.0.0.1:6379[2]\u0026gt; scan 0 count 20 type list 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;mylist\u0026#34; 2) \u0026#34;mylist2\u0026#34; 3) \u0026#34;mylist1\u0026#34; 3. sscan sscan key cursor [MATCH pattern] [COUNT count]，sscan的第一个参数总是集合类型的key\n127.0.0.1:6379[2]\u0026gt; sadd myset1 a b c d (integer) 4 127.0.0.1:6379[2]\u0026gt; smembers myset1 1) \u0026#34;d\u0026#34; 2) \u0026#34;a\u0026#34; 3) \u0026#34;c\u0026#34; 4) \u0026#34;b\u0026#34; 127.0.0.1:6379[2]\u0026gt; sscan myset1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;d\u0026#34; 2) \u0026#34;c\u0026#34; 3) \u0026#34;b\u0026#34; 4) \u0026#34;a\u0026#34; 127.0.0.1:6379[2]\u0026gt; sscan myset1 0 match a 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;a\u0026#34; 4. hscan hscan key cursor [MATCH pattern] [COUNT count]，sscan的第一个参数总是哈希类型的key\n127.0.0.1:6379[2]\u0026gt; hset myhset1 kk1 vv1 kk2 vv2 kk3 vv3 (integer) 3 127.0.0.1:6379[2]\u0026gt; hgetall myhset1 1) \u0026#34;kk1\u0026#34; 2) \u0026#34;vv1\u0026#34; 3) \u0026#34;kk2\u0026#34; 4) \u0026#34;vv2\u0026#34; 5) \u0026#34;kk3\u0026#34; 6) \u0026#34;vv3\u0026#34; 127.0.0.1:6379[2]\u0026gt; hscan myhset1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;kk1\u0026#34; 2) \u0026#34;vv1\u0026#34; 3) \u0026#34;kk2\u0026#34; 4) \u0026#34;vv2\u0026#34; 5) \u0026#34;kk3\u0026#34; 6) \u0026#34;vv3\u0026#34; 5. zscan zscan key cursor [MATCH pattern] [COUNT count]，sscan的第一个参数总是有序集合类型的key\n127.0.0.1:6379[2]\u0026gt; zadd myzadd1 1 zz1 2 zz2 3 zz3 (integer) 3 127.0.0.1:6379[2]\u0026gt; zrange myzadd1 0 -1 withscores 1) \u0026#34;zz1\u0026#34; 2) \u0026#34;1\u0026#34; 3) \u0026#34;zz2\u0026#34; 4) \u0026#34;2\u0026#34; 5) \u0026#34;zz3\u0026#34; 6) \u0026#34;3\u0026#34; 127.0.0.1:6379[2]\u0026gt; zscan myzadd1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;zz1\u0026#34; 2) \u0026#34;1\u0026#34; 3) \u0026#34;zz2\u0026#34; 4) \u0026#34;2\u0026#34; 5) \u0026#34;zz3\u0026#34; 6) \u0026#34;3\u0026#34; ","permalink":"https://hanson-study.netlify.app/posts/tech/tech1/","summary":"1. 介绍 scan命令的作用和keys *的作用类似，主要用于查找redis中的键，但是在正式的生产环境中一般不会直接使用keys *这个命令，因为他会返回所有的键，如果键的数量很多会导致查询时间很长，进而导致服务器阻塞，所以需要scan来进行更细致的查找 scan总共有这几种命令：sca","title":"Redis scan命令学习"},{"content":"","permalink":"https://hanson-study.netlify.app/posts/life/life/","summary":"","title":"Life"},{"content":"","permalink":"https://hanson-study.netlify.app/posts/read/read/","summary":"","title":"Read"},{"content":"\rSulv\u0026#39;s Blog\r一个记录技术、阅读、生活的博客\r","permalink":"https://hanson-study.netlify.app/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客","title":"🤝友链"},{"content":"嵌入式点灯工程师\n开发版收集者\n其他的想到再更....\n","permalink":"https://hanson-study.netlify.app/about/","summary":"嵌入式点灯工程师 开发版收集者 其他的想到再更....","title":"🙋🏻‍♂️关于"}]