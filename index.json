[{"content":"本文原发于三号放映厅公众号，现将其存档放出\n让它消失，就解决了？\n星期二, 四月 7, 2020\n8:12 上午\n让它消失，就解决了？ 写在前面\n几天前，独立影像圈子里发生了一场**「蝴蝶效应」**。\n影迷应该都猜到我说的是哪件事情了。\n3月29日，晚上临睡前，我偶然在微博上刷到博主@苏北人的一条微博：\n仔细翻了翻评论后，才了解此话的缘由。\n原来是一部聚焦“底层”的公益纪录片**《矿民、马夫、尘肺病》**因为题材敏感，无法在主流媒体进行传播，更没办法公映。\n再加上一直以来独立电影人的创作处境艰难，资金不足。\n为了能传播出去，让更多的人去关注底层群体的困境。\n无奈之下，导演蒋能杰只好在豆瓣蹲着，给每一个标记“想看”的人私信发资源，附上了一段话，还细心地说明了下载教程。\n很多人被导演这种坚持的行为打动了，于是开始在微博上主动转发扩散，互相传递资源。\n轻轻扇动几下翅膀就这样引发了一系列连锁反应。\n很快，这部纪录片在第二天被顶上**“豆瓣实时榜第一”**。\n标记人数从最初的几百个到现在（发文前）“6673人看过，4.5万人想看”，开画9分，目前回落到8.7分。\n那天晚上我和一个从事独立电影相关工作的朋友聊起这个事。\n我说我很感动。\n他说他也是。\n我说我也觉得很可悲。\n他说他也是。\n《矿民、马夫、尘肺病》\n这是一部聚焦**“尘肺病”**的公益纪录片。\n在我国公布的十大类职业病中，尘肺病属于发病率最高的一类，我国也是尘肺病患者最多的国家之一。\n我特地去查了一下近年的数据：2018年全国职业病报告中显示，尘肺病全年新增病例19468例，患得比例高达83%。\n通常来说，这种病是由于在职业活动中防护不到位，导致长期吸入生产性粉尘并且在肺内滞留，持续病变所引发的全身性疾病。\n轻者咳嗽、胸痛，重者呼吸困难、完全丧失基本的劳动能力，目前还没有研发出可以根治尘肺病的特效药。\n而患得这种病的，大多是矿民。\n尽管对于他们来说，尘肺病的危险程度并不亚于矿难，但他们在劳动力市场上处于劣势地位决定了他们别无选择。\n为了养家糊口，甚至只是为了吃口饭活下去，只能拿命换钱。\n导演的爸爸就是尘肺病患者之一，他的家乡湖南湘西南地区由于经济发展缓慢，矿产资源丰富，因此也成为了尘肺病患病率很高的地区。\n从2010年起，蒋能杰扛起摄影机开始跟拍了三位矿民。\n拍一阵子，出去接活赚点钱，回来再拍，就这么断断续续拍了八年，最终剪成了这部82分钟时长的作品。\n片中的几位主角也都是生活在他周围的人，其中马夫是他的爸爸，牵牛是他的堂弟。\n虽然片子的画质很差，前半段剪辑得也有些散乱，但依然不妨碍它夹杂着一种粗砺而尖锐的真实。\n从很多地方你都能感受到导演是在以一种平视的角度去记录他们。\n他将自己完全置于矿民群体之中，让镜头跟随着他们的生活一起移动，跟着他们上山下山，钻进矿洞。\n在这份真实之下，还是导演对底层群体的尊重。\n他没有批判或赞扬这些人，也没有刻意渲染他们的悲苦。\n比如片子的最后，即使是面对人们在亲人离世时的那种悲痛欲绝，摄影师也只是用一个固定镜头远远地在一旁记录这些人难以自控的本能反应。\n我想导演之所以拍这些，不是为了让那些比他们站的更高的人低头同情踩在脚下的人，为底层人民与不幸的抗争而感动。\n他只是试图去建立一种理解和反思。\n告诉你那些你不相信的事情是真实存在的，让你看到如今在我们的国家仍然有人过着一种这样的生活。\n关于“底层”我们之前已经用肯·洛奇的两部电影聊的很清楚了，今天就不再对底层群体进行过多的讨论。\n我甚至觉得以往那种悲天悯人的情绪在这部片子面前都显得很廉价。\n就如同导演克制的镜头一样，接下来我也只是把我所看到的那些被主流社会所忽视、被边缘化的人们的故事讲给你们听。\n因为他们跟我们一样，是人，不是社会发展的牺牲品。\n一\n矿民\n我们就按照片名的顺序，先从矿民讲起吧。\n片子里的矿民姓刘，别人都叫他“牵牛”，牵牛从17岁起就辍学回家，跟着父亲一起在山上开矿了。\n当矿工纯粹是个体力活。\n整天就是钻在矿洞里把墙上的矿石打下来，再装上小车再运出来，就这么不停地进进出出。\n不干活的时候，他们都呆在用石头垒起来的简易房子里聊聊天，打打牌，蹲在地下做些粗茶淡饭围在一起吃。\n晴天还能吃上新鲜的菜，下雪天送菜的上不了山，实在没得吃了就把一种类似老鼠的动物皮扒了烤着吃。\n此时，牵牛的工友扭头过来对着镜头无奈地说：“我累的半死，又没赚到什么钱“。\n然后转过身推着矿车继续向前走去。\n看得出来，起初这些人面对突如其来的镜头，有些恐惧和防备。\n每次当摄影机靠近他们的时候，有人就开玩笑大喊着：“搞整顿的来了”，也有人嘴里正儿八经地念叨着：“真的不要去拍，这东西不能拍”。\n倒也不是吓唬人，他们嘴里提到最多的“整顿”二字，的确是隔三岔五常发生的事。\n虽说是整顿，其实根本谈不上。\n不过是花钱请了一些“烂仔”过来吓唬他们，有些时候那些人不打一声招呼就直接烧了他们住的地方，砸了他们的机器。\n不过比起工作的时候随时都能要了命，这些都是还能应付的“小事情”。\n开矿洞需要炸药，但真炸药又买不到，最后只能用带有毒性的假炸药。\n牵牛讲起之前有个矿洞出了事，老板急着让进去救人。\n结果工人们**“进去一个倒一个”**，四五个人就这样活活被毒死，最后政府补偿了几百万才息事宁人。\n这不，正说着，昨天下面的矿洞又发生了一场一模一样的矿难，毒死了好几个人。\n人死了得往山下抬，但抬死人得花钱。\n有的人为了省钱，只把活着的往山下抬，“死的就不抬了”。\n矿民们聊起这些的时候，就像聊家常似的看起来格外轻松，好像见得多了，对于**“死亡”**这件事已经麻木了。\n但你要说他们不害怕也是假的。\n牵牛索性连看都不去看，“眼不见为净，我没看见，我一个人睡觉就不怕”。\n山上积着一层厚厚的雪，眼看着就要过年了。\n有的人抽空跑去山头跟自己的老婆打了个电话，多余话也不说，就是通知一声回家的日期，然后又继续钻进矿洞里。\n他们来不及去思考什么，也顾不上关心那么多。\n唯一在意的不过是作为“人”最基本的肉体欲望和生存欲望。\n脑子里算计着能赚多少钱，嘴里唱着“讨亲要讨大奶婆”。\n只不过每天无论是在狭窄矿洞里面，还是走出来，生活好像都没什么太大的差别。\n一样地黑暗，压抑，弓着背，弯着腰。\n要是没个灯照着，根本看不见一点光。\n二\n马夫\n马夫蒋美林也干着跟开矿有关的活。\n2007年，他和妻子从广东回到家乡后买了几匹马，开始了运送矿物和非法开采矿洞的营生，偶尔也冒风险送一送炸药。\n在片子的前半段里，关于马夫的镜头大多都是阴暗的。\n为了要防止被那些整顿的人抓住，他们经常半夜两三点就得出发，牵着马顺着崎岖的山路往上走，一走就是两三个小时。\n有的时候货都送到了，天才蒙蒙亮。\n虽然看起来如此辛苦，但从当时的价格“35块钱运100斤的矿”算下来，压根赚不到几个钱。\n即便马夫们的身上没有背货，你也能感觉到，他们和马一样，全身负重。\n好景不长，大概是在2012年左右，矿价下跌，物价上涨，开矿的成本变得越来越高，再加上政府对非法开采加强了整顿，许多矿洞都倒闭了。\n彼时，牵牛的矿洞也出了矿难，全家举债赔偿。\n没人开矿也就没有货可运，马夫蒋美林随之丢了工作。\n他和妻子只好回家种地，然后用之前送货赚来的钱再借了些，不为别的，就为盖个新房子给两个儿子娶媳妇。\n得空了，蒋美林还会再上山到以前辛苦工作过的矿洞去看看，砍砍杂草，敲一敲生了锈的旧机器。\n尘肺病的潜伏期非常长，发病又滞后，它会从肺部开始一点点地击垮人的身体。\n蒋美林是在1996年的时候查出来患得尘肺病的，直到2016年，他已经身患多种疾病，再也无法从事体力劳动了，只能在家休养。\n聊起当时开矿的那些经历，马夫的儿子开玩笑说：“我爸这辈子运气不好，存不了钱”。\n他们不知道自己可以怪谁，真要怪起来，就只能怪天命。\n三\n尘肺病\n像他们这样长期在粉尘浓度高的矿洞里干活的人，极其容易患上尘肺病，可是这些人大概连书都没读过几年，根本不知道尘肺病是什么。\n发现得早了，像马夫蒋美林那样的，还能通过治疗得以延缓。\n一旦发现晚了，像蒋美林的工友赵品凤这种打矿打了二十年后，检查出来已经是晚期的，就只有在家等死。\n如今到了从这个屋子走到另一个屋子就得马上吸氧的地步，赵品凤知道自己活不了多长时间了。\n他让摄影师帮他拍一张寿相（遗像），想着**“多活一个月算一个月”。**\n已经做好准备，毫无预兆地随时死去。\n他也知道，对于他们这些被甩在最后面的人来说，上面颁布的那些所谓的政策再好，下面不落实，说什么都没有用。\n这类职业病的工伤认定和补偿本就难度大，像同村那个诊断书上写着“由矽肺引起肺结核”的，拿到医院去，人家根本不给报销。\n那一年，他申请低保领了900块，可在医院一天就要100块，治不起病，也没钱再供女儿上学，全家都靠着弟弟寄些钱撑着过下去。\n生活就跟开玩笑似的。\n原本是为了谋生才得上了这么一个“穷病”，现在又因病返贫，仿佛成了一个没有出路的死循环。\n透过镜头，就这么眼睁睁地看着赵品凤头上戴的吸氧管从一根塑料管变成了一根绳子。\n广播里播着最新的扶贫政策，把每一个活生生的人变成了数据。\n另一头的他，身体每况愈下，连上个楼梯都很费力。\n明明是同一个画面，却让我恍惚地以为是两个平行的世界。\n那些电视机里念的、街道的宣传栏上写的，每一个听起来充满希望的词语，似乎都跟他们的毫无关系。\n最终，赵品凤于2018年死在了一个停电、吸不上氧的夜里。\n生死完全不由他自己，靠运气。\n棺材合上的那一瞬间，亲人们瘫在地上痛哭着拍打棺材盖，妻子站在一旁不忍靠近。\n他们还给他生前拍的那张寿相的背后，p上了一个天an门的背景。\n写在最后\n写完这篇文的时候，正好看到导演发了一条微博。\n这应该不是导演第一次遇到这样的声音，也是实在忍无可忍才挂了出来。\n他们认为导演拍的是**“负能量”，觉得“穷就是不够努力、不配活着”，声称“这种导演应该被抓起来”**，这种声音在我们号的留言区也不少见。\n我们先不说这种恶意揣测导演心血动机行为是多大的恶。\n我就想替导演问问你们这群人，你们真的觉得自己是在爱这个国家吗？\n什么叫正能量，什么叫负能量？\n我来告诉你们：\n不管好还是坏，夸赞还是批评，说的是真话，那就是正能量。\n坏的看不到，整天捂着别人嘴巴，蒙着自己眼睛唱赞歌，那才叫坏透了的负能量。\n何为爱国？\n爱它不是一种盲目的崇拜，不是去一味地歌颂感激，不是只允许宏大叙事的主旋律电影存在，不是把苦难美化成感动。\n而是说真话，是关切每一个个体，是指出不足并且督促解决问题，然后防止下一次错误的发生。\n一个国家由人民组成，你怎么样，决定了这个国家怎么样。\n爱国的本质，是爱这个国家的人民，是对苦难保持痛感和共情，是对悲鸣学会低头和聆听，是小心自己不要被成为一个吃喝拉撒见死不救的动物。\n是实事求是，是力所能及。\n所以很显然，当你把同胞的苦难冷血地划入不该被关注的“负能量”的时候，你看似爱国，实则早已站在了爱国的对立面。\n你们才是于这个国家最有害的人。\n我们爱这个国家，所以我们才必须说出它的不足，希望它更好。\n这是我们爱它的方式，我相信也是这部纪录片的创作者爱它的方式。\nPs：\n最后，感谢导演用近十年的时间坚持记录，非常不容易。\n如果你看到了这篇文，希望你抽时间去看看这部纪录片，只需要1个小时20分钟，不会浪费你太多时间，如果可以的话再推荐给身边的朋友看看。\n我们写了这么多，也只是希望它能被更多人看到。\n（本片的豆瓣讨论区）\n","permalink":"https://hanson-study.netlify.app/posts/read/%E8%AE%A9%E4%BB%96%E6%B6%88%E5%A4%B1%E5%B0%B1%E8%A7%A3%E5%86%B3%E4%BA%86/","summary":"本文原发于三号放映厅公众号，现将其存档放出 让它消失，就解决了？ 星期二, 四月 7, 2020 8:12 上午 让它消失，就解决了？ 写在前面 几天前，独立影像圈子里发生了一场**「蝴蝶效应」**。 影迷应该都猜到我说的是哪件事情了。 3月29日，晚上临睡前，我偶然在微博上刷到博主@苏北人的一条微博： 仔细翻了翻评论","title":"让他消失，就解决了？"},{"content":"Ts快速入门 编程语言介绍 ArkTS是HarmonyOS优选的主力应用开发语言。它在TypeScript（简称TS）的基础上，匹配ArkUI框架，扩展了声明式UI、状态管理等相应的能力，让开发者以更简洁、更自然的方式开发跨端应用。要了解什么是ArkTS，我们首先要了解下ArkTS、TypeScript和JavaScript之间的关系：\nJavaScript是一种属于网络的高级脚本语言，已经被广泛用于Web应用开发，常用来为网页添加各式各样的动态功能，为用户提供更流畅美观的浏览效果。 TypeScript 是 JavaScript 的一个超集，它扩展了 JavaScript 的语法，通过在JavaScript的基础上添加静态类型定义构建而成，是一个开源的编程语言。 ArkTS兼容TypeScript语言，拓展了声明式UI、状态管理、并发任务等能力。 由此可知，TypeScript是JavaScript的超集，ArkTS则是TypeScript的超集，他们的关系如下图所示：\n在学习ArkTS声明式的相关语法之前，我们首先学习下TypeScript的基础语法。\r基础类型 TypeScript支持一些基础的数据类型，如布尔型、数组、字符串等，下文举例几个较为常用的数据类型，我们来了解下他们的基本使用。\n布尔值\nTypeScript中可以使用boolean来表示这个变量是布尔值，可以赋值为true或者false。\nlet isDone: boolean = false; 数字\nTypeScript里的所有数字都是浮点数，这些浮点数的类型是 number。除了支持十进制，还支持二进制、八进制、十六进制。\nlet decLiteral: number = 2023; let binaryLiteral: number = 0b11111100111; let octalLiteral: number = 0o3747; let hexLiteral: number = 0x7e7; 字符串\nTypeScript里使用 string表示文本数据类型， 可以使用双引号（ \u0026ldquo;）或单引号（\u0026rsquo;）表示字符串。\nlet name: string = \u0026#34;Jacky\u0026#34;;name = \u0026#34;Tom\u0026#34;;name = \u0026#39;Mick\u0026#39;; 数组\nTypeScrip有两种方式可以定义数组。 第一种，可以在元素类型后面接上 []，表示由此类型元素组成的一个数组。\nlet list: number[] = [1, 2, 3]; 第二种方式是使用数组泛型，Array\u0026lt;元素类型\u0026gt;。\nlet list: Array\u0026lt;number\u0026gt; = [1, 2, 3]; 元组\n元组类型允许表示一个已知元素数量和类型的数组，各元素的类型不必相同。 比如，你可以定义一对值分别为 string和number类型的元组。\nlet x: [string, number]; x = [\u0026#39;hello\u0026#39;, 10];// OK x = [10, \u0026#39;hello\u0026#39;]; // Error 枚举\nenum类型是对JavaScript标准数据类型的一个补充，使用枚举类型可以为一组数值赋予友好的名字。\nenum Color {Red, Green, Blue}; let c: Color = Color.Green; Unknown\n有时候，我们会想要为那些在编程阶段还不清楚类型的变量指定一个类型。这种情况下，我们不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查。那么我们可以使用unknown类型来标记这些变量。\nlet notSure: unknown = 4; notSure = \u0026#39;maybe a string instead\u0026#39;; notSure = false; Void\n当一个函数没有返回值时，你通常会见到其返回值类型是 void。\nfunction test(): void { console.log(\u0026#39;This is function is void\u0026#39;);} Null 和 Undefined\nTypeScript里，undefined和null两者各自有自己的类型分别叫做undefined和null。\nlet u: undefined = undefined;let n: null = null; 联合类型\n联合类型（Union Types）表示取值可以为多种类型中的一种。\nlet myFavoriteNumber: string | number;myFavoriteNumber = \u0026#39;seven\u0026#39;;myFavoriteNumber = 7; 条件语句 条件语句用于基于不同的条件来执行不同的动作。TypeScript 条件语句是通过一条或多条语句的执行结果（True 或 False）来决定执行的代码块。\nif 语句\nTypeScript if 语句由一个布尔表达式后跟一个或多个语句组成。\nvar num:number = 5if (num \u0026gt; 0) { console.log(\u0026#39;数字是正数\u0026#39;) } if\u0026hellip;else 语句\n一个 if 语句后可跟一个可选的 else 语句，else 语句在布尔表达式为 false 时执行。\nvar num:number = 12; if (num % 2==0) { console.log(\u0026#39;偶数\u0026#39;); } else { console.log(\u0026#39;奇数\u0026#39;); } if\u0026hellip;else if\u0026hellip;.else 语句\nif\u0026hellip;else if\u0026hellip;.else 语句在执行多个判断条件的时候很有用。\nvar num:number = 2 if(num \u0026gt; 0) { console.log(num+\u0026#39; 是正数\u0026#39;) } else if(num \u0026lt; 0) { console.log(num+\u0026#39; 是负数\u0026#39;) } else { console.log(num+\u0026#39; 为0\u0026#39;) } switch…case 语句\n一个 switch 语句允许测试一个变量等于多个值时的情况。每个值称为一个 case，且被测试的变量会对每个 switch case 进行检查。\nvar grade:string = \u0026#39;A\u0026#39;; switch(grade) { case \u0026#39;A\u0026#39;: { console.log(\u0026#39;优\u0026#39;); break; } case \u0026#39;B\u0026#39;: { console.log(\u0026#39;良\u0026#39;); break; } case \u0026#39;C\u0026#39;: { console.log(\u0026#39;及格\u0026#39;); break; } case \u0026#39;D\u0026#39;: { console.log(\u0026#39;不及格\u0026#39;); break; } default: { console.log(\u0026#39;非法输入\u0026#39;); break; } } 函数 函数是一组一起执行一个任务的语句，函数声明要告诉编译器函数的名称、返回类型和参数。TypeScript可以创建有名字的函数和匿名函数，其创建方法如下：\n// 有名函数function add(x, y) { return x + y;} // 匿名函数let myAdd = function (x, y) { return x + y;}; 为函数定义类型\n为了确保输入输出的准确性，我们可以为上面那个函数添加类型：\n// 有名函数：给变量设置为number类型function add(x: number, y: number): number { return x + y;} // 匿名函数：给变量设置为number类型let myAdd = function (x: number, y: number): number { return x + y;}; 可选参数\n在TypeScript里我们可以在参数名旁使用 ?实现可选参数的功能。 比如，我们想让lastName是可选的：\nfunction buildName(firstName: string, lastName?: string) { if (lastName) return firstName + \u0026#39; \u0026#39; + lastName; else return firstName;} let result1 = buildName(\u0026#39;Bob\u0026#39;);let result2 = buildName(\u0026#39;Bob\u0026#39;, \u0026#39;Adams\u0026#39;); 剩余参数\n剩余参数会被当做个数不限的可选参数。 可以一个都没有，同样也可以有任意个。 可以使用省略号（ \u0026hellip;）进行定义：\nfunction getEmployeeName(firstName: string, ...restOfName: string[]) { return firstName + \u0026#39; \u0026#39; + restOfName.join(\u0026#39; \u0026#39;);} let employeeName = getEmployeeName(\u0026#39;Joseph\u0026#39;, \u0026#39;Samuel\u0026#39;, \u0026#39;Lucas\u0026#39;, \u0026#39;MacKinzie\u0026#39;); 箭头函数\nES6版本的TypeScript提供了一个箭头函数，它是定义匿名函数的简写语法，用于函数表达式，它省略了function关键字。箭头函数的定义如下，其函数是一个语句块：\n( [param1, parma2,…param n] )=\u0026gt; { // 代码块} 其中，括号内是函数的入参，可以有0到多个参数，箭头后是函数的代码块。我们可以将这个箭头函数赋值给一个变量，如下所示：\nlet arrowFun = ( [param1, parma2,…param n] )=\u0026gt; { // 代码块} 如何要主动调用这个箭头函数，可以按如下方法去调用：\narrowFun(param1, parma2,…param n) 后面，我们在学习HarmonyOS应用开发时会经常用到箭头函数。例如，给一个按钮添加点击事件，其中onClick事件中的函数就是箭头函数。\nButton(\u0026#34;Click Now\u0026#34;) .onClick(() =\u0026gt; { console.info(\u0026#34;Button is click\u0026#34;) }) 类 TypeScript支持基于类的面向对象的编程方式，定义类的关键字为 class，后面紧跟类名。类描述了所创建的对象共同的属性和方法。\n类的定义\n例如，我们可以声明一个Person类，这个类有3个成员：一个是属性（包含name和age)，一个是构造函数，一个是getPersonInfo方法，其定义如下所示。\nclass Person { private name: string private age: number constructor(name: string, age: number) { this.name = name; this.age = age; } public getPersonInfo(): string { return `My name is ${this.name} and age is ${this.age}`; } } 通过上面的Person类，我们可以定义一个人物Jacky并获取他的基本信息，其定义如下：\nlet person1 = new Person(\u0026#39;Jacky\u0026#39;, 18); person1.getPersonInfo(); 继承\n继承就是子类继承父类的特征和行为，使得子类具有父类相同的行为。TypeScript中允许使用继承来扩展现有的类，对应的关键字为extends。\nsuper关键字可以用来访问父类的构造方法\nclass Employee extends Person { private department: string constructor(name: string, age: number, department: string) { super(name, age); this.department = department; } public getEmployeeInfo(): string { return this.getPersonInfo() + ` and work in ${this.department}`; } } 通过上面的Employee类，我们可以定义一个人物Tom，这里可以获取他的基本信息，也可以获取他的雇主信息，其定义如下：\nlet person2 = new Employee(\u0026#39;Tom\u0026#39;, 28, \u0026#39;HuaWei\u0026#39;);person2.getPersonInfo();person2.getEmployeeInfo(); 在TypeScript中，有public、private、protected修饰符，其功能和具体使用场景大家可以参考TypeScript的相关学习资料，进行拓展学习。\n模块 随着应用越来越大，通常要将代码拆分成多个文件，即所谓的模块（module）。模块可以相互加载，并可以使用特殊的指令 export 和 import 来交换功能，从另一个模块调用一个模块的函数。\n两个模块之间的关系是通过在文件级别上使用 import 和 export 建立的。模块里面的变量、函数和类等在模块外部是不可见的，除非明确地使用 export 导出它们。类似地，我们必须通过 import 导入其他模块导出的变量、函数、类等。\n导出\n任何声明（比如变量，函数，类，类型别名或接口）都能够通过添加export关键字来导出，例如我们要把NewsData这个类导出，代码示意如下：\nexport class NewsData { title: string; content: string; constructor(title: string, content: string) { this.title = title; this.content = content; } } 导入\n模块的导入操作与导出一样简单。 可以使用以下 import形式之一来导入其它模块中的导出内容。\nimport { NewsData } from \u0026#39;../common/bean/NewsData\u0026#39;; 迭代器 当一个对象实现了Symbol.iterator属性时，我们认为它是可迭代的。一些内置的类型如Array，Map，Set，String，Int32Array，Uint32Array等都具有可迭代性。\nfor..of 语句\nfor..of会遍历可迭代的对象，调用对象上的Symbol.iterator方法。 下面是在数组上使用for..of的简单例子：用于遍历对象\nlet someArray = [1, \u0026#34;string\u0026#34;, false]; for (let entry of someArray) { console.log(entry); // 1, \u0026#34;string\u0026#34;, false} for..of vs. for..in 语句\nfor..of和for..in均可迭代一个列表，但是用于迭代的值却不同：for..in迭代的是对象的键，而for..of则迭代的是对象的值。用于遍历下标，打印下标\nlet list = [4, 5, 6]; for (let i in list) { console.log(i); // \u0026#34;0\u0026#34;, \u0026#34;1\u0026#34;, \u0026#34;2\u0026#34;,} for (let i of list) { console.log(i); // \u0026#34;4\u0026#34;, \u0026#34;5\u0026#34;, \u0026#34;6\u0026#34;} ","permalink":"https://hanson-study.netlify.app/posts/tech/ts%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","summary":"Ts快速入门 编程语言介绍 ArkTS是HarmonyOS优选的主力应用开发语言。它在TypeScript（简称TS）的基础上，匹配ArkUI框架，扩展了声明式UI、状态管理等相应的能力，让开发者以更简洁、更自然的方式开发跨端应用。要了解什么是ArkTS，我们首先要了解下ArkTS、","title":"鸿蒙应用开发Ts快速入门"},{"content":"1. 介绍 scan命令的作用和keys *的作用类似，主要用于查找redis中的键，但是在正式的生产环境中一般不会直接使用keys *这个命令，因为他会返回所有的键，如果键的数量很多会导致查询时间很长，进而导致服务器阻塞，所以需要scan来进行更细致的查找\nscan总共有这几种命令：scan、sscan、hscan、zscan，分别用于迭代数据库中的：数据库中所有键、集合键、哈希键、有序集合键，命令具体结构如下：\nscan cursor [MATCH pattern] [COUNT count] [TYPE type] sscan key cursor [MATCH pattern] [COUNT count] hscan key cursor [MATCH pattern] [COUNT count] zscan key cursor [MATCH pattern] [COUNT count] 2. scan scan cursor [MATCH pattern] [COUNT count] [TYPE type]，cursor表示游标，指查询开始的位置，count默认为10，查询完后会返回下一个开始的游标，当返回0的时候表示所有键查询完了\n127.0.0.1:6379[2]\u0026gt; scan 0 1) \u0026#34;3\u0026#34; 2) 1) \u0026#34;mystring\u0026#34; 2) \u0026#34;myzadd\u0026#34; 3) \u0026#34;myhset\u0026#34; 4) \u0026#34;mylist\u0026#34; 5) \u0026#34;myset2\u0026#34; 6) \u0026#34;myset1\u0026#34; 7) \u0026#34;mystring1\u0026#34; 8) \u0026#34;mystring3\u0026#34; 9) \u0026#34;mystring4\u0026#34; 10) \u0026#34;myset\u0026#34; 127.0.0.1:6379[2]\u0026gt; scan 3 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;myzadd1\u0026#34; 2) \u0026#34;mystring2\u0026#34; 3) \u0026#34;mylist2\u0026#34; 4) \u0026#34;myhset1\u0026#34; 5) \u0026#34;mylist1\u0026#34; MATCH可以采用模糊匹配找出自己想要查找的键，这里的逻辑是先查出20个，再匹配，而不是先匹配再查询，这里加上count 20是因为默认查出的10个数中可能不能包含所有的相关项，所以把范围扩大到查20个，我这里测试的键总共有15个\n127.0.0.1:6379[2]\u0026gt; scan 0 match mylist* count 20 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;mylist\u0026#34; 2) \u0026#34;mylist2\u0026#34; 3) \u0026#34;mylist1\u0026#34; TYPE可以根据具体的结构类型来匹配该类型的键\n127.0.0.1:6379[2]\u0026gt; scan 0 count 20 type list 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;mylist\u0026#34; 2) \u0026#34;mylist2\u0026#34; 3) \u0026#34;mylist1\u0026#34; 3. sscan sscan key cursor [MATCH pattern] [COUNT count]，sscan的第一个参数总是集合类型的key\n127.0.0.1:6379[2]\u0026gt; sadd myset1 a b c d (integer) 4 127.0.0.1:6379[2]\u0026gt; smembers myset1 1) \u0026#34;d\u0026#34; 2) \u0026#34;a\u0026#34; 3) \u0026#34;c\u0026#34; 4) \u0026#34;b\u0026#34; 127.0.0.1:6379[2]\u0026gt; sscan myset1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;d\u0026#34; 2) \u0026#34;c\u0026#34; 3) \u0026#34;b\u0026#34; 4) \u0026#34;a\u0026#34; 127.0.0.1:6379[2]\u0026gt; sscan myset1 0 match a 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;a\u0026#34; 4. hscan hscan key cursor [MATCH pattern] [COUNT count]，sscan的第一个参数总是哈希类型的key\n127.0.0.1:6379[2]\u0026gt; hset myhset1 kk1 vv1 kk2 vv2 kk3 vv3 (integer) 3 127.0.0.1:6379[2]\u0026gt; hgetall myhset1 1) \u0026#34;kk1\u0026#34; 2) \u0026#34;vv1\u0026#34; 3) \u0026#34;kk2\u0026#34; 4) \u0026#34;vv2\u0026#34; 5) \u0026#34;kk3\u0026#34; 6) \u0026#34;vv3\u0026#34; 127.0.0.1:6379[2]\u0026gt; hscan myhset1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;kk1\u0026#34; 2) \u0026#34;vv1\u0026#34; 3) \u0026#34;kk2\u0026#34; 4) \u0026#34;vv2\u0026#34; 5) \u0026#34;kk3\u0026#34; 6) \u0026#34;vv3\u0026#34; 5. zscan zscan key cursor [MATCH pattern] [COUNT count]，sscan的第一个参数总是有序集合类型的key\n127.0.0.1:6379[2]\u0026gt; zadd myzadd1 1 zz1 2 zz2 3 zz3 (integer) 3 127.0.0.1:6379[2]\u0026gt; zrange myzadd1 0 -1 withscores 1) \u0026#34;zz1\u0026#34; 2) \u0026#34;1\u0026#34; 3) \u0026#34;zz2\u0026#34; 4) \u0026#34;2\u0026#34; 5) \u0026#34;zz3\u0026#34; 6) \u0026#34;3\u0026#34; 127.0.0.1:6379[2]\u0026gt; zscan myzadd1 0 1) \u0026#34;0\u0026#34; 2) 1) \u0026#34;zz1\u0026#34; 2) \u0026#34;1\u0026#34; 3) \u0026#34;zz2\u0026#34; 4) \u0026#34;2\u0026#34; 5) \u0026#34;zz3\u0026#34; 6) \u0026#34;3\u0026#34; ","permalink":"https://hanson-study.netlify.app/posts/tech/tech1/","summary":"1. 介绍 scan命令的作用和keys *的作用类似，主要用于查找redis中的键，但是在正式的生产环境中一般不会直接使用keys *这个命令，因为他会返回所有的键，如果键的数量很多会导致查询时间很长，进而导致服务器阻塞，所以需要scan来进行更细致的查找 scan总共有这几种命令：sca","title":"Redis scan命令学习"},{"content":"\rSulv\u0026#39;s Blog\r一个记录技术、阅读、生活的博客\r","permalink":"https://hanson-study.netlify.app/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客","title":"🤝友链"},{"content":"嵌入式点灯工程师\n开发版收集者\n其他的想到再更....\n","permalink":"https://hanson-study.netlify.app/about/","summary":"嵌入式点灯工程师 开发版收集者 其他的想到再更....","title":"🙋🏻‍♂️关于"}]